# 0. Lambda
하나의 거대한 애플리케이션에서 가가의 서비스를 담당하는 모듈단위로 분리하는것을 micro service, 그러한 아키텍처를 MSA이죠. 이런 MSA를 위해서 AWS에서 강력하게 지원하는 컴퓨팅 기능이 Lambda.

# 1. 함수 관리
## 콘솔 화면
### 디자이너
- 트리거  
함수를 호풀하도록 구성한 서비스 및 리소스  
보통은 이벤트 소스 매핑하거나 다른 서비스에서 트리거를 구성
- 계층  
응용 프로그램에 추가.  
라이브러리, 사용자 지정 런타임 또는 기타 종속항목을 포함  
개발중인 함수의 코드에서 변경되지 않는 코드 및 리소스를 별도로 관리할 수 있음  
특히 순서가 중요함.. /opt 디렉토리 아래에 순서대로 추출하여 덮어쓰게 되므로, 첫번째 레이어는 Custom Runtime, 두번째부터 라이브러리 추천  
함수당 최대 5개 계층
region에 75GB 사용가능하고, funtion당 256mb 제한됨.

- 대상  
호출 결과에 대한 세부 정보를 다른 서비스에 전송  
비동기식으로 호출하거나, 스트림에서 읽는 이벤트 소스 매핑을 총해 레코드를 전송

### 함수 설정
- 코드 : 함수의 코드와 종속 항목입니다.  
스크립트 언어의 경우, 내장된 편집기에서 함수 코드를 편집할 수 있습니다.  
라이브러리를 추가하려면 또는 편집기가 지원하지 않는 언어의 경우 배포 패키지(Zip파일)를 업로드(lambda api, aws cli, sdk)합니다.  
배포 패키지가 50MB보다 큰 경우 Upload a file from Amazon S3(Amazon S3에서 파일 업로드)를 선택합니다.  
/tmp 공간을 512MB 제공

- 런타임 : 함수를 실행하는 Lambda 런타임입니다.

- 핸들러 : index.handler 등 함수가 호출될 때 런타임이 실행하는 메서드입니다.  
첫 번째 값은 파일 또는 모듈의 이름입니다.  
두 번째 값은 메서드의 이름입니다.

- 환경 변수 : 실행 환경에서 Lambda가 설정하는 키-값 페어입니다.  
환경 변수를 사용하여 코드 외부에서 함수의 구성을 확장합니다.  
한도 : 4KB  
예약된 환경 변수 : AWS_REGION, LAMBDA_FUNCTION_NAME, MEMORY, VERSION, TZ 등등

- 태그 : Lambda가 함수 리소스에 연결하는 키-값 페어입니다.  
태그를 사용하여 Lambda 콘솔에서 비용 보고 및 필터링을 위해 Lambda 함수를 그룹별로 분류합니다.  
태그는 전체 함수(모든 버전과 별칭을 포함)에 적용됩니다.

- 설명 : 함수에 대한 설명입니다.

- 메모리 : 실행 과정에서 함수가 사용할 수 있는 메모리의 양입니다.  
128MB-3,008 MB 범위에서 선택합니다(64MB 간격).  
Lambda는 구성된 메모리 크기에 선형 비례하여 CPU 용량을 할당합니다.  
1,792MB에서 함수는 전체 vCPU 하나와 동등한 값을 갖습니다(초당 1 vCPU-초 크레딧).

- 제한 시간 : Lambda에서 함수를 중지하기 전에 실행을 허용하는 시간입니다.  
기본값은 3초입니다. 허용되는 최댓값은 900초입니다.

- 적극 추적 : 수신 요청을 샘플링하고 AWS X-Ray로 샘플링된 요청을 추적합니다.

- Virtual private cloud(VPC) : 해당 함수가 인터넷을 통해 사용할 수 없는 리소스에 대한 네트워크에 액세스해야 할 경우 VPC에 연결하도록 구성합니다.

- Concurrency(동시성) : 함수에 대한 최대 동시 실행 횟수를 설정하는 함수의 동시성을 예약합니다. 지연 시간의 변동 없이 함수가 확장할 수 있도록 동시성을 프로비저닝합니다.  
예약된 동시성은 전체 함수(모든 버전과 별칭을 포함)에 적용됩니다.  
동시실행 : 1000

- 비동기식 호출 : 처리되지 않은 이벤트를 Lambda에서 폐기하기 전에 해당 이벤트가 대기열에 있는 시간 또는 Lambda에서 시도하는 재시도 횟수를 줄이도록 오류 처리 동작을 구성합니다.  
폐기된 이벤트를 유지하도록 배달 못한 편지 대기열을 구성합니다.  
함수, 버전 또는 별칭에 대해 오류 처리 설정을 구성할 수 있습니다.

- 데이터베이스 프록시 : Amazon RDS DB 인스턴스 또는 클러스터를 사용하는 함수에 대한 데이터베이스 프록시를 생성합니다.

- Execution role(실행 역할) : IAM 역할이 함수를 실행할 때 AWS Lambda가 수임하는 IAM 역할입니다.

### 동시성
동시성 : 특정 시각에 함수가 제공하는 요청의 수  
Lambda는 함수가 호출되면 인스턴스를 할당하여 이벤트를 처리, 함수 코드가 실행을 마치면, 다른 요청을 처리, 요청을 처리하는 동안 함수가 다시 호출되면, 다른 인스턴스가 할당되어 함수의 동시성이 증가. 단 동시실행(1000)이고 이는 리전 제한임.   

#### 예약된 동시성 구성  
특정 lambda에 할당되는 동시성  
1. 한도를 설정하므로, 함수가 제어 범위 밖으로 확장할 수 없음  
2. 다른 함수가 예약된 함수의 영역을 침범 할 수가 없음

#### 프로비저닝된 동시성 구성
에약된 동시성 + 버전과 별칭에 할당되는 동시성

### 버전&별칭 관리

### 계층
Lambda 함수는 추가 코드와 콘텐츠를 계층의 형태로 가져오도록 구성할수 있다.  
하나의 계층은 라이브러리, 사용자 지정 런타임 또는 그 외 종속성을 포함하는 ZIP 아카이브이다.  
배포 패키지에 라이브러리를 포함시킬 필요 없이 계층을 통해 함수에서 라이브러리를 사용할 수 있다??  
최대 5개 계층, 압축 해제된 배포 패키지의 크기 제한은 250MB 초과 불가  

### 네트워크
본인의 계정에서 VPC(Virtual Private Cloud)의 프라이빗 서브넷에 연결되도록 함수를 구성 가능.  
eg) 데이터베이스, 캐시 인스턴스, 내부 서비스 등과 같은 리소스 엑세스

# 2. 함수 호출
## 동기식 호출
Lambda는 함수를 실행하고 응답을 기다리는 구조  
예제는 AWS CLI 중 aws lambda invoke 명령을 통해 response.json을 반환하는 방식
예) API Gateway  
페이로드 : 6MB

## 비동기식 호출
Amazon S3 및 Amazon SNS 같은 여러 AWS 서비스는 이벤트를 처리하기 위해 비동기적으로 함수를 호출  
Amazon SQS  
Amazon SNS  
AWS Lambda  
Amazon EventBridge  
페이로드 : 256KB

## 이벤트 소스 매핑
이벤트 소스(이벤트 트리거)에서 읽어 AWS Lambda 함수를 호출  
Kinesis, DynamoDB, Amazon SQS

## 함수 구모 조정
## 오류 처리
일반적인 호출 오류  
**요청** : 요청 이벤트가 너무 대용량이거나 유효한 JSON이 아닌 경우, 함수가 존재하지 않는경우,  또는 파라미터 값의 형식이 잘못  
**호출자** : 사용자 또는 서비스는 함수를 호출할 권한이 없는  
**계정** : 최대 개수의 함수 인스턴스가 이미 실행 중이거나 요청이 너무 빠르게 수행

일반적인 함수 오류  
**함수** : 함수 코드에 예외가 발생하거나 오류 객체를 반환  
**런타임** : 함수가 시간을 초과하였거나 구문 오류를 감지했거나 응답 객체를 JSON으로 표현하는데 실패하여 런타임이 함수를 종료  

비동기 호출 : 두번 재시도, 요청을 처리할 용량이 충분하지 않으면 대기, 성공적으로 처리되지 않은 이벤트를 dead letter queue로 구성  
이벤트 소스 매핑 : 스트립 읽는 배치를 재시도, 그럼에도 반복되는 오휴는 해결되거나 항목이 만료 될때까지 처리를 차단.


# 3. 런타임
## 런타임 지원 정책
런타임이 수명종료(EOL)될 경우 지속적인 지원은 기대하기 어렵다.
Python2.7은 2020/01/01 EOL되었으나, 현재 사용 중단이 예정되지 않으나, 고객에게 사전 공지나 알림을 제공해주기 때문에 그전에 마이그레이션을 준비해야함.

## 사용자 지정 런타임
예로 c++같이 지원되지 않는 런타임의 경우 직접 구성하여 사용할수도 있다.


# 4.애프리케이션
Lambda만 사용하는 경우는 거의 없다  
작업을 수행하는 데 함께 작동하는 Lambda 함수, 이벤트 소스 및 기타 리소스의 조합  
사용되는 서비스를 보면 기본적으로 IaC 기반 Lambda 구성에 적합.


## 사용 사례
monitoring  
cloudwatch alarm -> Lambda  -> Email/Slack or Run command  -> replace resource -> Ansible Execute Playbook

web application  
API Gateway -> Lambda -> DynamoDB

serverless batch processing  
S3 -> Lambda Splitter -> Lambda Mappers -> DynamoDB -> Lambda Reducer -> S3 


## Best Practice
Cold Start vs. Warm Start
- 일정 기간 이상 실행되지 않을 경우 Stand-by중인 컨테이너가 하나도 남지 않게 되어 호출 시 소요 시간이 증가됨.
- VPC에 위치한 경우 Cold Start시 ENI를 Attach 하기 때문에 소요 시간이 더 증가
- CloudWatch TIme-based Event 통해 주기적인 Warm-up 필요

1. 코드 패키지 사이즈 최소화
2. Lambda Handler와 Core Logic을 분리
3. Execution Context 재사용을 활용  
핸들러 외부에서 SDK 클라이언트 및 데이터베이스 연결을 초기화 하고, 정적 자산은 /tmp 디렉토리에 로컬로 캐시  
4. Environent Variable을 적극 활용  
S3 버킷을 사용하는 경우 버킷 이름을 하드 코딩 대신 환경 변수로 구성  
5. 자바의 경우 .jar 파일들으르 별도의 /lib 디렉토리에 배치  
다수의 .class 파일이 있는게 단일 .jar에 모든 함수를 배치하는것 보다 빠르다. 
또한 단순한 프레임워크를 선호 : Spring보단 Dagger, Guice  
6. Max Memory Used 사이즈는 Lambda Function 실행에 충분할 정도로만
7. 사용되지 않는 Lambda는 삭제
8. API 스로틀링에 대비  
동기식 : 429에러  
비동기식 : 최대6시간 동안 호출 재시도  
스트림 기반 이벤트 소스 : 최대 7일간 호출 재시도  
9. 반드시 필요한 경우에만 VPC에 배치
10. CloudWatch Custom Metrics통해 필요한 지표들을 추가 기록
11. X-Ray를 이용해 Trace
12. 리커시브 코드 사용하지마라.  

cron expression은 UTC 기반..  
이떄 초단위 정밀함은 지원 안됨.  
(예) 매일 00:00 실행 00:00:00~00:00:59 사이에 실행.  
초단위까지 설정이 필요하면, EC2/ECS에 NTP및 Cron 설정으로 해결